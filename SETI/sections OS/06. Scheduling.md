---
title: 06. Scheduling
date: 2023-01-15
tags: SETI-OS, process, scheduler, algorithm
difficulty: üü†
---

<h1  style="text-align: center;">  06. Scheduling üìã</h1> 

Abbiamo parlato qui [[06. Virtualizzazione#Virtualizzazione della CPU]] di come ad ogni programma durante l'esecuzione gli venga dato una porzione di memoria e di CPU per essere eseguito
Abbiamo anche parlato qui [[05. Architettura Moderna#Pipeline]] di come ad ogni processo venga dedicato un tot di tempo di esecuzione per poi passare al successivo per *"simulare"* un'esecuzione parallela dei programmi.

Questo meccanismo di passare da un processo all'altro si chiama **Contex Switch** e il software che si occupa di fare ci√≤ si chiama **Scheduler** e si trova **all'interno del Kernel** e decide chi √® il prossimo processo da mandare in esecuzione secondo una certa **Policy**.

Il sistema operativo decide che policy utilizzare, in modo tale che l'esecuzione dei processi sia:
- **veloce.**
- **efficiente.**
- **un processo non prenda il controllo del sistema** (per esempio un processo che fa un loop infinito).

Esistono due approcci per evitare l'ultimo punto:
- **Approccio cooperativo:** ci fidiamo che i nostri processi eseguano delle syscall di tanto in tanto ridando il controllo al kernel.
- **Approccio non cooperativo:** Il kernel si riprende il controllo dopo un tot di tempo delimitato da un **timer interrupt**.


# Contex-Switch

Il content switch si occupa di switchare da un processo all'altro, per farlo bisogna:
- **salvare** i registri del processo che si sta eseguendo
- **caricare** i registri del processo che si vuole eseguire

![[Pasted image 20230114163048.png|center|500]]


# Stati di un Processo

Abbiamo parlato di processi qui [[05. Processi]], ogni processo ha uno stato:
- **New**
- **Ready**
- **Suspend/Ready**
- **Run**
- **Wait/Block**
- **Suspend/Wait**
- **Termination**

![[Pasted image 20230114163239.png|center|500]]


# Metriche




# Algoritmi di Scheduling






# [[05. Processi|‚Üê Prev]] | [[07. Thread| Next ‚Üí]]






# Flashcards

Che approcci utilizza l'OS per evitare che i processi non prendano il controllo del sistema
?
- Approccio **cooperativo.**
- Approccio **non cooperativo.**

Su cosa si basa l'**approccio cooperativo** di uno scheduler:: Il kernel si ***"confida"*** nel fatto che il **processo esegua delle syscall** ogni tanto ridando il controllo al kernel.

Su cosa si basa l'**approccio non cooperativo** di uno scheduler:: Il kernel si **riprende il controllo** del sistema **dopo un tot di tempo** definito da un **timer interrupt**.


Quali sono gli stati di un processo
?
- **New**
- **Ready**
- **Suspend/Ready**
- **Run**
- **Wait/Block**
- **Suspend/Wait**
- **Termination**


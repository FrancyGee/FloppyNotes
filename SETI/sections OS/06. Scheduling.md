---
title: 06. Scheduling
date: 2023-01-15
tags: SETI-OS, process, scheduler, algorithm
difficulty: üü†
---

<h1  style="text-align: center;">  06. Scheduling üìã</h1> 

Abbiamo parlato qui [[06. Virtualizzazione#Virtualizzazione della CPU]] di come ad ogni programma durante l'esecuzione gli venga dato una porzione di memoria e di CPU per essere eseguito
Abbiamo anche parlato qui [[05. Architettura Moderna#Pipeline]] di come ad ogni processo venga dedicato un tot di tempo di esecuzione per poi passare al successivo per *"simulare"* un'esecuzione parallela dei programmi.

Questo meccanismo di passare da un processo all'altro si chiama **Contex Switch** e il software che si occupa di fare ci√≤ si chiama **Scheduler** e si trova **all'interno del Kernel** e decide chi √® il prossimo processo da mandare in esecuzione secondo una certa **Policy**.

Il sistema operativo decide che policy utilizzare, in modo tale che l'esecuzione dei processi sia:
- **veloce.**
- **efficiente.**
- **un processo non prenda il controllo del sistema** (per esempio un processo che fa un loop infinito).

Esistono due approcci per evitare l'ultimo punto:
- **Approccio cooperativo:** ci fidiamo che i nostri processi eseguano delle syscall di tanto in tanto ridando il controllo al kernel.
- **Approccio non cooperativo:** Il kernel si riprende il controllo dopo un tot di tempo delimitato da un **timer interrupt**.

Nel contesto dello scheduling i processi in esecuzione vengono chiamati **job**.

# Contex-Switch

Il content switch si occupa di switchare da un processo all'altro, per farlo bisogna:
- **salvare** i registri del processo che si sta eseguendo
- **caricare** i registri del processo che si vuole eseguire

![[Pasted image 20230114163048.png|center|500]]


# Stati di un Processo

Abbiamo parlato di processi qui [[05. Processi]], ogni processo ha uno stato:
- **New:** 
	- Il processo **viene creato** ma non √® ancora pronto per l'esecuzione
- **Ready:** 
	- Il processo √® **pronto per l'esecuzione** ma non sta utilizzando le risorse del pc (cpu, memoria)
- **Suspend/Ready:**
	- Il processo √® sospeso ed in stato di *ready*.
- **Run:**
	- Il processo viene eseguito e utilizza le risorse del pc (cpu, memoria).
- **Wait/Block:**
	- Il processo √® **in attesa di un evento esterno** per continuare l'esecuzione, ad esempio un input dell'utente o un segnale di sistema
- **Suspend/Wait:**
	- Il processo viene sospeso temporaneamente ed in stato di *wait*.
- **Termination:**
	- Il processo √® stato **completato** o **interrotto** e vengono restituiti i risultati e **deallocate le risorse**

![[Pasted image 20230114163239.png|center|500]]


> [!info] Suspend
> Lo stato suspend viene utilizzato dal sistema operativo **quando un processo che richiede molte risorse del sistema** possa sovraccaricarlo.



# Metriche

Le metriche servono a valutare e confrontare i diversi algoritmi di scheduling, esistono diverse metriche che valutano i **Job**, eccone alcune:
- **Tempo di risposta:**
	- Il **tempo trascorso tra la richiesta di un processo e la sua prima risposta**. Questa metrica √® importante per le applicazioni interattive, in cui un tempo di risposta rapido √® essenziale per un'esperienza utente soddisfacente.
- **Tempo di attesa:**
	- Il tempo trascorso tra la richiesta e l'esecuzione completa di un processo.
- **Utilizzo della CPU:**
	- Quanta percentuale di CPU ha utilizzato il processo.
- **Turnaround time:**
	- Il tempo trascorso tra la richiesta e l'esecuzione completa di un processo **esclude il tempo trascorso in coda in attesa di risorse**.
- **Tempo di attesa medio:**
	- Il tempo medio di attesa di tutti i processi eseguiti.
- **Throughput:**
	- Il numero di processi completati in un dato lasso di tempo, utile per le applicazioni che effettuano  tante richieste
- **Fairness:**
	- La capacit√† del sistema di **distribuire equamente le risorse** tra processi


# Algoritmi di Scheduling

In base alle metriche esistono diversi tipi di algoritmi di scheduling.

## FIFO

**First in First Out** √® un algoritmo molto semplice che come dice il nome il primo job che arriva sar√† anche il primo ad essere eseguito, questo algoritmo andrebbe bene se ogni processo avesse lo stesso tempo di esecuzione ma in un contesto reale questa cosa √® impossibile.

Questo approccio √® sconsigliato perch√© altamente inefficiente come vedremo con il prossimo capitolo.

## Shortest Job First

In questo caso per evitare che il un processo pi√π veloce rallenti la coda, si decide di far eseguire prima i job pi√π corti in modo tale che il tempo di esecuzione si riduca.

**ESEMPIO:**
prendiamo tre processi $A,B,C$ con tempi di esecuzione $A=100, B=10, C=10$

Nel caso mettessimo il processo A davanti come farebbe il FIFO avremo un tempo di esecuzione:
$$
\frac{100+110+120}{3} = 110
$$

Mentre se utilizzassimo l'algoritmo Shortest Job First:
$$
\frac{10+20+120}{3} = 50
$$
Abbiamo praticamente dimezzato il tempo di esecuzione.

Ci sono due problemi:
- i processi pi√π corti potrebbero arrivare dopo e quindi verrebbe eseguito prima i processi pi√π lungi.
- Potrebbero accodarsi tantissimi processi corti impedendo l'esecuzione di processi pi√π lungi (**starvation**).

## Round-Robin

Il round robin spezzetta ogni processo in sottoprocessi di dimensione uguale per ridurre il tempo di esecuzione
Il problema di ridurre l'esecuzione dei processi in piccolissimi lassi di tempo richiede un continuo richiamo al **Context-Switch**


## MLFQ

**Multi-Level Feedback Queue** √® un algoritmo che gestisce lo scheduling analizzando le operazioni passate dei processi e in base a questo assegnare ad ognuno di essi una priorit√† di esecuzione.

I processi vengono inseriti in code a diversi livelli a seconda della loro priorit√†, la priorit√† viene scelta in base a:
- Il **tempo di utilizzo** della CPU di un processo.
- Che **tipo di operazione** esegue il processo (CPU o I/O).
Se per esempio un processo fa I/O ha una priorit√† maggiore in quanto occupa meno tempo l'esecuzione.

Solitamente comunque i processi con **priorit√† pi√π alta** hanno un **tempo di esecuzione breve** mentre i processi con **priorit√† pi√π bassa** hanno un **tempo di esecuzione maggiore**

Anche qui come il round robin un job potrebbe rimanere in priorit√† bassa e non venire mai eseguito.


![[Pasted image 20230114234206.png|center|500]]


## CFS

**Completely Fair Scheduler** √® uno degli scheduler utilizzati da Linux, esso si basa sulla teoria del **fair share** ovvero **distribuire in modo equo le risorse** del sistema tra tutti i processi in esecuzione.

Il CFS non alloca le risorse in base ad un livello di priorit√† ma piuttosto controlla:
- La quantit√† di risorse utilizzate dal processo 
- Il tempo trascorso dal processo in attesa di risorse (**virtual runtime**)

La coda di schedulazione del CFS √® un **albero binario red-black** ordinato per virtual runtime, vedi [[05. Alberi]] dove per trovare il minimo impiego $\log(n)$ tempo. 

Con i processi I/O per evitare che *"Monopolizzino"* la CPU, ogni qualvolta che il processo in questione diventa ready dopo uno sleep o init, gli viene impostato il **vruntime** minimo attualmente nell'albero.

>[!note] 
>**VRUNTIME = VIRTUAL RUNTIME**

# [[05. Processi|‚Üê Prev]] | [[07. Thread| Next ‚Üí]]






# Flashcards

Che approcci utilizza l'OS per evitare che i processi non prendano il controllo del sistema
?
- Approccio **cooperativo.**
- Approccio **non cooperativo.**

Come viene chiamato un processo in esecuzione quando parliamo di scheduling:: **Job.**


Su cosa si basa l'**approccio cooperativo** di uno scheduler:: Il kernel si ***"confida"*** nel fatto che il **processo esegua delle syscall** ogni tanto ridando il controllo al kernel.

Su cosa si basa l'**approccio non cooperativo** di uno scheduler:: Il kernel si **riprende il controllo** del sistema **dopo un tot di tempo** definito da un **timer interrupt**.


Quali sono gli stati di un processo
?
- **New**
- **Ready**
- **Suspend/Ready**
- **Run**
- **Wait/Block**
- **Suspend/Wait**
- **Termination**

Cosa succede nello stato **New**:: Viene creato un nuovo processo.

Cosa succede nello stato **Ready**:: Vengono **allocate le risorse** per l'esecuzione del processo.

Cosa succede nello stato **Run**:: Viene **eseguito** il processo.

Cosa succede nello stato **Wait/Block**:: Il processo rimane in **attesa** di un **evento estero**

Cosa succede nello stato **Terminated**:: Viene **terminato** il processo e **deallocate le risorse**.

Cosa succede nello stato **Suspend/Wait**:: Viene **sospeso** il processo in **stato wait.**

Cosa succede nello stato **Suspend/Ready**:: Viene **sospeso** il processo in **stato ready.**

Cos'√® la **starvation**:: Quando tanti  processi con un tempo di esecuzione minore impediscono l'esecuzione di processi con un tempo di esecuzione maggiore.

Nel **MLFQ** in base a cosa √® data la priorit√†
?
- Al **tipo di operazione** svolta dalla cpu.
- **tempo di esecuzione** del processo.

Perch√© si usa un **albero binario red-black** per la coda dei processi nel **CFS**:: Per avere un tempo $\log(n)$ nella **ricerca del minimo**.
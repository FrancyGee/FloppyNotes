---
title: 07. Thread
date: 2023-01-15
tags: SETI-OS, thread, cpu, process 
difficulty: üü†
---

<h1  style="text-align: center;">  07. Thread </h1> 

Per ora abbiamo parlato di esecuzione dei processi come se stessimo lavorando su una CPU single core e ogni processo utilizzava per un tot di tempo le risorse del computer e poi si passava al processo successivo.

I thread ci permettono di avere **pi√π flussi di esecuzione in un processo**, quando si va a creare un thread √® come se si creasse una **CPU virtuale**.

Un thread **non √® un programma**, **non pu√≤ essere eseguito** per conto suo, √® invece un qualcosa che **viene eseguito insieme a un programma**:

![[Pasted image 20230115105827.png|center|300]]


# Gestione delle Risorse

Ogni thread condivide:
- **L'ambiente globale di un processo**: variabili, risorse esterne (file aperti) ecc...
- **Heap del processo**
- **Identit√† del processo**: PID, owner ecc..
- **File descriptor aperti**

Inoltre i **thread condividono lo spazio di indirizzamento del processo padre** perci√≤ **per evitare conflitti** bisogna adottare **meccanismi di protezione e sincronizzazione**.

Non viene invece condiviso:
- **Registri del thread**
- **Priorit√† e Policy di Scheduling**
- **Identit√† del thread:** TID.
- **Segnali** 
- **Informazioni sul contesto del thread**

## TLS 

Ogni thread ha il proprio stack il [tls (Thread Local Storage)](https://en.wikipedia.org/wiki/Thread-local_storage)  √® lo spazio locale logico di ogni thread, solitamente accessibile con un'interfaccia dizionario **chiave/valore**, per capire come funziona vedi [[04. Hash Table]].

## Vantaggi dei Thread

I vantaggi dei thread sono: 
- sfruttare il **parallelismo** per evitare, per esempio che le operazioni di **I/O** si "blocchino".
- **Miglior utilizzo delle risorse del sistema,** per esempio effettuare un content-switch tra thread richiede meno risorse rispetto a farlo tra processi perch√© condividono lo stesso spazio di indirizzamento.
- Creazione di **programmi multithread** che sfruttano la piena potenza della CPU.

Nonostante le CPU moderne hanno un maggior quantit√† di core, rimane necessario usufruire dei thread in quanto le operazioni che un computer svolge non √® coperto dalla quantit√† di core fisici.


# Thread in C

Per utilizzare i thread in *C* utilizziamo la libreria `<pthread.h>` dell'**API POSIX**

Per creare un thread utilizziamo:
```c
int pthread_create(pthread_t *restrict thread,
                   const pthread_attr_t *restrict attr,
                   void *(*start_routine)(void *),
                   void *restrict arg);
```

in ordine:
1. `thread` √® un puntatore al quale la funzione andr√† ad assegnare il TID.
2. `attr` sono le opzioni del thread, solitamente si passa `NULL`
3. `start_routine` √® un puntatore ad una funzione, ovvero il processo.
4. `arg`

La funzione ritorna:
- 0 se la funzione viene eseguita con successo
- restituisce il codice di errore (NON errno).

Per uscire da un thread:
```c
void pthread_exit(void *retval);
```

E per attendere la terminazione di un thread:
```c
int pthread_join(pthread_t thread, void **retval);
```
Dove:
1. `thread` √® il TID
2. `retval` √® il valore di ritorno del thread.

Un esempio di codice che utilizza queste funzioni:
```c
void *print_message_function( void *ptr );

int main()
{
     pthread_t thread1, thread2;
     const char *message1 = "Thread 1";
     const char *message2 = "Thread 2";
     int  iret1, iret2;

    /* Crea i thread */
    iret1 = pthread_create( &thread1, NULL, print_message_function, (void*) message1);
    iret2 = pthread_create( &thread2, NULL, print_message_function, (void*) message2);

    /* Attendiamo la terminazione dei thread */
    pthread_join( thread1, NULL);
    pthread_join( thread2, NULL); 

    printf("Thread 1 restituisce: %d\n",iret1);
    printf("Thread 2 restituisce: %d\n",iret2);
    return 0;
}

void *print_message_function( void *ptr )
{
     char *message;
     message = (char *) ptr;
     printf("%s \n", message);
}
```

Il programma crea due thread utilizzando la funzione `pthread_create()`.
- La prima chiamata crea un thread e lo fa eseguire la funzione `print_message_function()` passando `thread1` come argomento. 
- La seconda chiamata crea un altro thread e lo fa eseguire la stessa funzione passando `thread2` come argomento. 
- Entrambe le chiamate a `pthread_create()` restituiscono un valore intero che indica se la creazione √® avvenuta con successo o meno. 
- Il programma principale poi attende la terminazione dei thread utilizzando la funzione `pthread_join()`.

In questo programma non c'√® nessun meccanismo si sincronizzazione tra i thread e questo potrebbe causare problemi se i thread condividessero delle risorse che non sono protette. 



# [[06. Scheduling|‚Üê Prev]] | [[| Next ‚Üí]]






# Flashcards


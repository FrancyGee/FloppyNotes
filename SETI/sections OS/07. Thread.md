---
title: 07. Thread
date: 2023-01-15
tags: SETI-OS, thread, cpu, process 
difficulty: üü†
---

<h1  style="text-align: center;">  07. Thread </h1> 

Per ora abbiamo parlato di esecuzione dei processi come se stessimo lavorando su una CPU single core e ogni processo utilizzava per un tot di tempo le risorse del computer e poi si passava al processo successivo.

I thread ci permettono di avere **pi√π flussi di esecuzione in un processo**, quando si va a creare un thread √® come se si creasse una **CPU virtuale**.

Un thread **non √® un programma**, **non pu√≤ essere eseguito** per conto suo, √® invece un qualcosa che **viene eseguito insieme a un programma**:

![[Pasted image 20230115105827.png|center|300]]


# Gestione delle Risorse

Ogni thread condivide:
- **L'ambiente globale di un processo**: variabili, risorse esterne (file aperti) ecc...
- **Heap del processo**
- **Identit√† del processo**: PID, owner ecc..
- **File descriptor aperti**

Inoltre i **thread condividono lo spazio di indirizzamento del processo padre** perci√≤ **per evitare conflitti** bisogna adottare **meccanismi di protezione e sincronizzazione**.

Non viene invece condiviso:
- **Registri del thread**
- **Priorit√† e Policy di Scheduling**
- **Identit√† del thread:** TID.
- **Segnali** 
- **Informazioni sul contesto del thread**

## TLS 

Ogni thread ha il proprio stack il [tls (Thread Local Storage)](https://en.wikipedia.org/wiki/Thread-local_storage)  √® lo spazio locale logico di ogni thread, solitamente accessibile con un'interfaccia dizionario **chiave/valore**, per capire come funziona vedi [[04. Hash Table]].

## Vantaggi dei Thread

I vantaggi dei thread sono: 
- sfruttare il **parallelismo** per evitare, per esempio che le operazioni di **I/O** si "blocchino".
- **Miglior utilizzo delle risorse del sistema,** per esempio effettuare un content-switch tra thread richiede meno risorse rispetto a farlo tra processi perch√© condividono lo stesso spazio di indirizzamento.
- Creazione di **programmi multithread** che sfruttano la piena potenza della CPU.

Nonostante le CPU moderne hanno un maggior quantit√† di core, rimane necessario usufruire dei thread in quanto le operazioni che un computer svolge non √® coperto dalla quantit√† di core fisici.


# Thread in C

Per utilizzare i thread in *C* utilizziamo la libreria `<pthread.h>` dell'**API POSIX**

Per creare un thread utilizziamo:
```c
int pthread_create(pthread_t *restrict thread,
                   const pthread_attr_t *restrict attr,
                   void *(*start_routine)(void *),
                   void *restrict arg);
```

in ordine:
1. `thread` √® un puntatore al quale la funzione andr√† ad assegnare il TID.
2. `attr` sono le opzioni del thread, solitamente si passa `NULL`
3. `start_routine` √® un puntatore ad una funzione, ovvero il processo.
4. `arg`

La funzione ritorna:
- 0 se la funzione viene eseguita con successo
- restituisce il codice di errore (NON errno).

Per uscire da un thread:
```c
void pthread_exit(void *retval);
```

E per attendere la terminazione di un thread:
```c
int pthread_join(pthread_t thread, void **retval);
```
Dove:
1. `thread` √® il TID
2. `retval` √® il valore di ritorno del thread.

Un esempio di codice che utilizza queste funzioni:
```c
void *print_message_function( void *ptr );

int main()
{
     pthread_t thread1, thread2;
     const char *message1 = "Thread 1";
     const char *message2 = "Thread 2";
     int  iret1, iret2;

    /* Crea i thread */
    iret1 = pthread_create( &thread1, NULL, print_message_function, (void*) message1);
    iret2 = pthread_create( &thread2, NULL, print_message_function, (void*) message2);

    /* Attendiamo la terminazione dei thread */
    pthread_join( thread1, NULL);
    pthread_join( thread2, NULL); 

    printf("Thread 1 restituisce: %d\n",iret1);
    printf("Thread 2 restituisce: %d\n",iret2);
    return 0;
}

void *print_message_function( void *ptr )
{
     char *message;
     message = (char *) ptr;
     printf("%s \n", message);
}
```

Il programma crea due thread utilizzando la funzione `pthread_create()`.
- La prima chiamata crea un thread e lo fa eseguire la funzione `print_message_function()` passando `thread1` come argomento. 
- La seconda chiamata crea un altro thread e lo fa eseguire la stessa funzione passando `thread2` come argomento. 
- Entrambe le chiamate a `pthread_create()` restituiscono un valore intero che indica se la creazione √® avvenuta con successo o meno. 
- Il programma principale poi attende la terminazione dei thread utilizzando la funzione `pthread_join()`.

In questo programma non c'√® nessun meccanismo si sincronizzazione tra i thread e questo potrebbe causare problemi siccome i thread condividono delle risorse che non sono protette. 
Questa condivisione non protetta si chiama **sezione critica**.

Quando due thread accedono simultaneamente ad una risorsa condivisa ed effettuano entrambi delle modifiche causando dei problemi ci ritroviamo in una condizione di **race condition**.


# Sincronizzazione e Protezione delle risorse

Per evitare **race condition** esistono diversi metodi.

## Lock

La funzione lock permette a un thread di **bloccare l'accesso di una risorsa condivisa agli altri thread**.

Questo garantisce che solo un thread alla volta possa accedere alla risorsa e modificarla.

Esistono diversi tipi di lock
- **Spinlock:**
	- un thread che vuole accedere ad una risorsa controlla continuamente se la risorsa √® disponibile o meno, in attesa che lo diventi. Utile in sistemi con pochi core o in cui la risorsa viene rilasciata rapidamente.
- **Semafori:**
	- un thread che vuole accedere ad una risorsa modifica un contatore per acquisire il lock. Se il contatore √®:
		- 0,  **la risorsa √® gi√† in uso** e il thread deve attendere. 
		- Altrimenti, **il contatore viene decrementato** e il thread pu√≤ accedere alla risorsa. Il thread deve poi **incrementare il contatore per rilasciare la risorsa**.
- **Atomici:*
	- utilizzano operazioni di memoria atomica come **Compare And Swap (CAS)** per acquisire il lock. L'operazione CAS controlla se un valore in memoria √® uguale ad un valore previsto e, se √® cos√¨, lo modifica con un nuovo valore. In questo modo, solo il thread che effettua l'operazione con successo pu√≤ accedere alla risorsa.

In C per creare un lock utilizziamo la primitive di sincronizzazione dei thread come `pthread_mutex_t`.

Se un programma ha pi√π strutture dati condivise, √® meglio avere pi√π lock perch√©:
- Aumenta l'**efficienza**.
- Aumenta la **protezione** delle risorse.

## Mutex

- [ ] Completare Mutex (@2023-01-16)

## Deadlock

Il deadlock avviene quando due o pi√π processi/thread accedono in modo esclusivo ad una risorsa condivisa e aspettano entrambi il completamento dell'altro.

![[Pasted image 20230116050315.png|center|400]]

Questo pu√≤ avvenire in particolare quando:
- **mutual exclusion:**
	- I thread/processi hanno controllo esclusivo su una risorsa.
- **hold-and-wait:**
	- i thread mantengono le risorse acquisite mentre ne richiedono o aspettano altre.
- **no preeption:**
	- Le risorse non possono essere tolte.
- **circular wait:**
	- Ci deve essere un ciclo di attese.

Per prevenire questa condizione abbiamo un paio di soluzioni:
- **Exclusion:**
	- consiste nell'eliminare le condizioni che possono causare un deadlock, ad esempio, evitando di accedere a pi√π di una risorsa contemporaneamente.
- **Prevention:**
	- consiste nell'eliminare alcune delle condizioni che causano un deadlock, ad esempio, limitando l'accesso alle risorse.
- **Detection:**
	- consiste nell'identificare un deadlock quando si verifica e risolverlo, ad esempio, terminando uno dei thread/processi coinvolti.
- **Recovery:**
	- consiste nel ripristinare il sistema al suo stato normale dopo che un deadlock √® stato risolto, ad esempio, riportando le risorse ai loro valori iniziali.


# [[06. Scheduling|‚Üê Prev]] | [[08. Security| Next ‚Üí]]






# Flashcards

Cosa condividono i thread
?
- **L'ambiente globale di un processo**: variabili, risorse esterne (file aperti) ecc...
- **Heap del processo**
- **Identit√† del processo**: PID, owner ecc..
- **File descriptor aperti**
<!--SR:!2023-01-17,1,219-->

Cosa non condividono i thread
?
- **Registri del thread**
- **Priorit√† e Policy di Scheduling**
- **Identit√† del thread:** TID.
- **Segnali** 
- **Informazioni sul contesto del thread**
<!--SR:!2023-01-17,1,230-->

Cos'√® il **TLS**:: lo stack dedicato ad ogni thread
<!--SR:!2023-01-17,1,219-->

Con quale libreria si lavora sui thread:: `<pthread.h>`
<!--SR:!2023-01-17,1,230-->

Con che funzione si crea un thread:: `pthread_create()`
<!--SR:!2023-01-18,2,244-->

Con che funzione si esce da un thread:: `pthread_exit()`
<!--SR:!2023-01-17,1,219-->

Con che funzione si attende la terminazione di un thread:: `pthread_join()`
<!--SR:!2023-01-17,1,224-->

Cos'√® la **sezione critica**:: Quando dei thread condividono delle risorse non protette.
<!--SR:!2023-01-17,1,224-->

Cos'√® la **race condition**:: Quando due o pi√π thread accedono e modificano una risorsa condivisa simultaneamente portando a degli errori.
<!--SR:!2023-01-17,1,230-->

Cos'√® avviene un **deadlock**:: Quando due o pi√π thread/processi accedono esclusivamente ad una risorsa e rimangono in attesa l'uno dell'altro del loro completamento.
<!--SR:!2023-01-17,1,219-->

In che casi pu√≤ avvenire un **deadlock**
?
**mutual exclusion:**
	- I thread/processi hanno controllo esclusivo su una risorsa.
- **hold-and-wait:**
	- i thread mantengono le risorse acquisite mentre ne richiedono o aspettano altre.
- **no preeption:**
	- Le risorse non possono essere tolte.
- **circular wait:**
	- Ci deve essere un ciclo di attese.
<!--SR:!2023-01-17,1,224-->

Quali sono le tecniche per evitare un deadlock
?
- **Exclusion:**
	- consiste nell'eliminare le condizioni che possono causare un deadlock, ad esempio, evitando di accedere a pi√π di una risorsa contemporaneamente.
- **Prevention:**
	- consiste nell'eliminare alcune delle condizioni che causano un deadlock, ad esempio, limitando l'accesso alle risorse.
- **Detection:**
	- consiste nell'identificare un deadlock quando si verifica e risolverlo, ad esempio, terminando uno dei thread/processi coinvolti.
- **Recovery:**
	- consiste nel ripristinare il sistema al suo stato normale dopo che un deadlock √® stato risolto, ad esempio, riportando le risorse ai loro valori iniziali.
<!--SR:!2023-01-17,1,224-->


---
author: Floppy
date: 2022-12-15
tags: ADC, binary, numbers, conversion
---

<h1  style="text-align: center;"> Rappresentazione delle Informazioni </h1>
Il calcolatore utilizza il **sistema numerico binario (o base 2)** per rappresentare le informazioni, questo sistema utilizza solo due simboli $0$ e $1$  che fisicamente rappresentano lo stato degli elettroni che viaggiano nel nostro computer, zero significa che non passa (ha una carica molto bassa) nessun elettrone, uno significa che passa un elettrone.

Con questi soli due simboli noi possiamo comunicare con il calcolatore e rappresentare numeri, caratteri, frasi, immagini, video, audio ecc...

## Rappresentazione dei Numeri

Per rappresentare i numeri con il sistema binario ci basta convertire dalla **base 10** che utilizziamo noi alla **base 2** che il calcolatore interpreta, per farlo eseguiamo questa semplice operazione:
- Prendiamo un numero in base 10, esempio $14$.
- Dividiamo per $2$ il numero, e teniamo conto del resto, il risultato andrà diviso nuovamente per due e salveremo nuovamente il resto e così via.
- Quando la divisione da risultato $0$ ci fermiamo e mettiamo in ordine tutti i resti ottenuti dal primo all'ultimo.
- il numero che otterremo sarà l'equivalente binario del numero decimale di partenza.

$$
\begin{align}
& 14 : 2 = 7  \quad \text{resto } 0 \\
& 7 : 2 = 3  \quad \text{resto } 1 \\
& 3 : 2 = 1  \quad \text{resto } 1 \\
& 1 : 2 = 0  \quad \text{resto } 1 \\
\end{align}
$$
Il 14 in base 2 è $1110$

Se volessimo trasformare un numero binario in decimale dovremmo invece procedere in questo modo, prendiamo il numero $1011$, ogni cifra ha una posizione:

| $p_{n-1}$ | $p2$ | $p_{1}$ | $p_{0}$ |
| ------- | ---- | ------- | ------- |
| 1       | 0    | 1       | 1       |

Dove:
- $n$ è il numero di cifre del numero binario.
- $p_{n-1}$ è la **cifra più significativa**.
- $p_{0}$ è la **cifra meno significativa.**


Per riportare il numero da binario a decimale dovremo:
- Elevare 2 per il valore della posizione.
- Moltiplicare $2^{px}$ per il la cifra in posizione $px$
- Sommare tutti i prodotti di ogni posizione:

$$
1011 = 1\cdot 2^{3} + 0\cdot 2^{2} + 1\cdot 2^{1} + 1\cdot 2^{0} = 8 + 0  
+ 2 + 1 = 11 
$$

> [!NOTE] NOTA
> Se la cifra meno significativa è $1$ allora il numero è dispari, altrimenti è pari

Abbiamo utilizzato numeri positivi intero, in matematica abbiamo anche i numeri negativi, i numeri razionali, irrazionali, periodici ecc... che richiedono alcune regole specifiche per essere rappresentati.


## Numeri Interi

Con i numeri interi possiamo rappresentare:
- *numeri senza segno* (**Unsigned**).
- *numeri positivi*.
- *numeri negativi*.

#### Interi senza segno

Per gli interi senza segno la rappresentazione va da $0$ a $2^{n}-1$.
**ESEMPIO:**
con un $1$ byte possiamo rappresentare 256 numeri da $0$ a $255$.


#### Interi relativi

Per i numeri **interi relativi (interi con segno)** abbiamo bisogno  di rappresentare:
- *Il valore assoluto del numero.*
- *il segno del numero*.

Per fare ciò esistono tecniche differenti:
- **modulo e segno**
- **completamento a due**
- **eccesso-k**

#### **modulo e segno**

Il bit più significativo rappresenta il segno, gli altri $n-1$ rappresentano il numero.
**ESEMPIO:**
- $0111 =  +7$
- $1111 = -7$

> [!NOTE] NOTA
> Questa rappresentazione ci *"ruba"* un bit e quindi ci limita a rappresentare con $n$ bit solo $2^{n-1}-1$ numeri.

#### **complemento a due**

Nel complemento a due abbiamo una rappresentazione che ci permette di avere con $n$ bit 
$2^{n-1}$ cifre negative e $2^{n-1}-1$ cifre positive.

Nel complemento a due il numero negativo è l'inverso del numero positivo a cui viene poi sommato $1$.
Questo tipo di rappresentazione agevola l'utilizzo di algoritmi di somma e sottrazione per esempio con 4 bit abbiamo:
![[Pasted image 20221209164901.png|center]]

#### **eccesso-k**

per codificare in **eccesso k** un numero intero, si somma al numero il valore k e si converte il valore ottenuto in binario su n bit.

Con questo metodo noi possiamo rappresentare tutti i numeri interi da $-k$ a $2^{n-1}-k$.
Per esempio con 4 bit abbiamo:
![[Pasted image 20221209165057.png|center]]


### Numeri Reali

I numeri reali necessitano oltre che la rappresentazione del **numero**, del **valore assoluto** e del **segno**, anche della **parte decimale.**

Inoltre i con gli $\mathbb{R}$ noi abbiamo anche i numeri periodici e irrazionali che per limiti di memoria il calcolatore non può rappresentare.
In questi casi si parlerà quindi di metodi di approssimazione del numero.

Per rappresentare i numeri reali possiamo usufruire di due metodi:
- **Fixed Point**, rappresentazione a virgola fissa.
- **Floating Point**, rappresentazione a virgola mobile.


#### Fixed Point

La rappresentazione in **virgola fissa** ci permette di rappresentare numeri con la virgola di cui sappiamo già di quante cifre intere e di quante cifre decimali è composto.

Infatti nella rappresentazione a virgola fissa abbiamo con $n$ bit:
- 1 bit per il segno
- $i$ bit per la parte intera
- $f$ bit per la parte decimale
dove $f = n-i-1$.

Prendiamo per esempio n = 8, i=5, f=2 avremo che:
![[fixed_point_rappresentation.excalidraw|center]]

#### Floating Point (IEEE 754)

I floating point (definito nello **standard IEEE 754**) sono un metodo per rappresentare numeri reali con un certo numero di bit.
Essi sono costituiti da una parte intera ed una parte decimale.

Per rappresentare un numero con i floating point abbiamo bisogno di:
- Un bit per il **segno**.
- $m$ bit per **mantissa**. 
- $n$ bit per l'**esponente**. 

 I numeri in virgola mobile si possono rappresentare con la seguente formula : 
$$(-1)^s \times (1 + m ) \times 2^{n}$$
 dove:
 - $s$ è il bit del segno 
 - $m$ è la mantissa 

#### Arrotondamenti
Quando lavoriamo con numeri reali c'è sempre una certa approssimazione, poiché i numeri reali non possono essere rappresentati per intero in un sistema binario.
Ad esempio nella rappresentazione a virgola mobile IEEE 754, con 32 bit abbiamo:
- 1 bit per il segno.
- 23 bit per la mantissa.
- 8 bit per l'esponente.

Questo significa che non possiamo rappresentare tutti i numeri reali ottenendo come risultato una **approssimazione** del numero reale.


#### Double e Float

nella `libc` e nella IEEE 754 vi sono due tipi di floating point

| **TIPO** | **DIMENSIONE** | **SEGNO** | **ESPONENTE** | **MANTISSA** |
| -------- | -------------- | --------- | ------------- | ------------ |
| `float`  | 32 bit         | 1 bit     | 8 bit         | 23 bit       |
| `double` | 64 bit         | 1 bit     | 11 bit        | 52 bit       |

```c
#include <stdio.h>

int main()
{
	printf("Hello world");
	//printf("%lu\n", sizeof(float));  // 32
	//printf("%lu\n", sizeof(double)); // 64
}
```

---
title: 04. Hash Table
date: 2023-01-23
tags: ASD, hashtable, algorithm, searching
status: COMPLETE
difficulty: üü°
---

<h1  style="text-align: center;">  04. Hash Table </h1> 

Possiamo definire una hash table come un **array che utilizza una funzione hash** per inserire e cercare gli elementi.

Un hash table ideale ha come scopo di mantenere una complessit√† nella ricerca di un elemento pari a $O(1)$ e questo viene fatto implementando una **buona funzione di hash**.

# Funzione Hash

Una funzione di hash indicizza gli elementi nella nostra hash table applicando propriet√† matematiche al dato che stiamo andando ad inserire e lo deve fare in maniera randomica.

Quindi una funzione hash che ritorna un valore costante non va bene.

Una funzione come questa:
```embed-cpp
PATH:  "vault://_Code/ASD/hashtable/main.cpp"
LINES: 4, 60-71
TITLE: "ESEMPIO FUNZIONE HASH"
```

Le propriet√† che definiscono una buona hash table sono:
- **Accesso costante:**
	- La funzione di hash deve limitare la duplicazione di output che genera collisione nella hash table.
- **Tempo di ricerca efficiente:**
	- La funzione di hash come detto prima deve avere una complessit√† di ricerca pari a $O(1)$ o comunque ci si deve avvicinare.

La funzione che abbiamo implementato non evita la collisione degli elementi a lungo andare ma √® un buon esempio di partenza.


## Inserimento

L'inserimento in una hash table ha complessit√† $O(1)$, in generale inseriamo all'interno di una hash table in questo modo:
```embed-cpp
PATH:  "vault://_Code/ASD/hashtable/main.cpp"
LINES: 4, 9, 80-97
TITLE: INSERT HASH TABLE
```

Nel caso un elemento √® gi√† presente nella hash table, evitiamo di sovrascriverlo (collisione) e non lo inseriamo.


## Ricerca 

Anche la ricerca all'interno di un hash table ha complessit√† $O(1)$ e la implementiamo in questo modo:
```embed-cpp
PATH:  "vault://_Code/ASD/hashtable/main.cpp"
LINES: 4, 9, 113-123
TITLE: SEARCH HASH TABLE
```


## Remove

L'implementazione del `remove` di un elemento dentro l'hash table √® simile a quella del `search`:
```embed-cpp
PATH:  "vault://_Code/ASD/hashtable/main.cpp"
LINES: 4, 9, 126-138
TITLE: REMOVE HASH TABLE
```


# Dictionary

Come abbiamo visto in una hash table quando inseriamo due elementi uguali vanno in collisione e quindi non √® possibile inserire il secondo.
Per ovviare a questo problema si implementa una hash table i cui indirizzi sono delle [[02. Liste e Array Dinamici#Liste Semplici|linked list]].

![[ASD-dictionary|center|500]]

Ovviamente questo tipo di implementazione aumenta la complessit√† della nostra hash table, in questo caso infatti ci ritroveremo con:

**Insert:**
| Best Case | Worst Case |
| --------- | ---------- |
| $O(1)$    | O(1)           |

**Front Insert**
| Best Case | Worst Case |
| --------- | ---------- |
| $O(1)$    | O(n)           |

Nel caso in cui la lista sia vuota ci ritroviamo nel caso migliore .

**Search:**
| Best Case | Worst Case |
| --------- | ---------- |
| $O(1)$    | O(n)           |

Nel caso in cui la lista contiene un solo elemento o nessuno ci troviamo nel caso migliore.

**Delete:**
| Best Case | Worst Case |
| --------- | ---------- |
| $O(1)$    | O(1)           |

**Front Delete**

| Best Case | Worst Case |
| --------- | ---------- |
| $O(1)$    | O(n)           |

# [[03. Algoritmi di Ricerca|‚Üê Prev]] | [[05. Alberi| Next ‚Üí]]






# Flashcards

Quali sono le propriet√† che definiscono una buona funzione hash
?
- **Accesso costante:**
	- La funzione di hash deve limitare la duplicazione di output che genera collisione nella hash table.
- **Tempo di ricerca efficiente:**
	- La funzione di hash come detto prima deve avere una complessit√† di ricerca pari a $O(1)$ o comunque ci si deve avvicinare.

Complessit√† dell'`insert()` in una hash table:: $O(1)$

Complessit√† del `search()` in una hash table:: $O(1)$

Complessit√† del `remove()` in una hash table:: $O(1)$

Complessit√† del `delete()` in una hash table:: $O(n)$

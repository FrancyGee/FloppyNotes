---
title: 05. Alberi
date: 2023-02-06
tags: ASD, tree, searching
status: INCOMPLETE
difficulty: üü†
---

<h1  style="text-align: center;">  05. Alberi üå≤ </h1> 

Gli alberi sono **strutture dati di tipo gerarchico** e proprio per questa caratteristica servono a rappresentare dei dati che sono gerarchici per natura, ad esempio un albero genealogico, un filesystem ecc...

Solitamente si rappresentano in questo modo:
![[ASD-example_of_tree|center|400]]

Al **vertice** abbiamo la **root**, tutti i nodi che non sono **root** sono **child**, se i **child** hanno a loro volta dei **child** allora saranno la **root dei propri child**, i **child senza child** si chiamano **leaf** (foglie).


# Binary Search Tree

Un binary tree rispetta una regola fondamentale, data una root tutti gli elementi minori di essa andranno a sinistra e tutti quelli maggiori andranno alla destra.

Un esempio:

![[Pasted image 20230206100843.png|center|500]]


Un implementazione di un BST √® la seguente:
```embed-cpp
PATH: vault://_Code/ASD/tree/main.cpp
LINES: 4-8, 44-54
TITLE: BST E CREAZIONE NODI
```


```embed-cpp

```
La **complessit√†** del BST si basa sul come √® bilanciato l'albero in generale:

| Best Case | Worst Case |
| --------- | ---------- |
| $O(\log n)$    | $O(n)$           |

## Best Case

Ci ritroviamo nel best case quando l'albero √® ben bilanciato ovvero cos√¨:
![[Pasted image 20230206124610.png|center|400]]

## Worst Case

Ci ritroviamo nel worst case quando l'albero √® mal bilanciato, ovvero quando √® obliquo:
![[Pasted image 20230206124534.png|center|400]]

## Insert

L'implementazione dell'`insert` in un BST √® pi√π comoda se fatta con la ricorsione in questo modo:
```embed-cpp
PATH: vault://_Code/ASD/tree/main.cpp
LINES: 57-76
TITLE: INSERT IN UN BST
```

Prima di tutto vediamo che:
- se l'**albero √® vuoto** allora stiamo inserendo la **root** (che potrebbe essere anche un figlio.  
- se l'**albero ha una root** ma l'**elemento** che stiamo inserendo √® **uguale** alla root allora **non viene inserito**.
- Se l'**elemento √® minore della root** ci si sposta nel ramo a **sinistra**.
- Se l'**elemento √® maggiore della root** ci si sposta nel ramo a **destra**.

## Search

Anche per la `search` viene implementata la ricorsione per scorrere l'albero:

```embed-cpp
PATH: vault://_Code/ASD/tree/main.cpp
LINES: 79-94
TITLE: SEARCH IN UN BST
```


## Delete

Ci sono tre casi di `delete` nel BST:
1. Il nodo da cancellare √® **una foglia**.
2. Il nodo da cancellare ha solo **un child**.
3. il nodo da cancellare ha **due child**.

Il delete ha complessit√†:
| Best Case    | Worst Case |
| ------------ | ---------- |
| $O(\log(n))$ | $O(n)$           |

Un'implementazione di un delete √® la seguente:
```embed-cpp
PATH: vault://_Code/ASD/tree/main.cpp
LINES: 97-106, 109-140
TITLE: DELETE IN UN BST
```



# Binary Heap

Un binary heap √® un tipo di albero binario che implementa alcune propriet√† specifiche:
- **Max Heap**.
- **Min Heap**.

Solitamente questo tipo di albero si utilizza per rappresentare code di priorit√†, l'ordinamento di algoritmi di ricerca e l'**algoritmo Dijkstra** di cui approfondiremo [[06. Grafi|qui]].

## Max Heap

Il max heap ha la propriet√† di avere il valore di ogni nodo **uguale o maggiore** ai suoi figli.
Il nodo **root** avr√† quindi il **valore massimo di tutto l'albero**.

![[ASD-Lettura_Heap_Max|center|400]]

## Min Heap

Il min heap viceversa ha la propriet√† di avere il valore di ogni nodo **uguale o minore** ai suoi figli.
Il nodo **root** avr√† quindi il **valore minimo di tutto l'albero**.

![[ASD-Lettura_Heap_Min|center|400]]


- [ ] Aggiungere le funzioni `insert`, `delete`, `search` (@2023-02-28)


# Black and Red Tree

- [ ] Completare Black and Red Tree (@2023-02-28)

# [[04. Hash Table|‚Üê Prev]] | [[06. Grafi| Next ‚Üí]]





# Flashcards

